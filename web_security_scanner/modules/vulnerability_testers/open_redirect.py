"""
Open Redirect Vulnerability Tester
"""

import urllib.parse
from typing import List, Dict
from .base_tester import BaseVulnerabilityTester


class OpenRedirectTester(BaseVulnerabilityTester):
    """Tests for open redirect vulnerabilities"""
    
    def get_payloads(self) -> List[str]:
        """Get open redirect payloads"""
        return [
            'https://evil.com',
            'http://evil.com',
            '//evil.com',
            '///evil.com',
            '////evil.com',
            'https:evil.com',
            'http:evil.com',
            'https:/evil.com',
            'http:/evil.com',
            '/\\evil.com',
            '\\/evil.com',
            'https://evil.com/',
            'javascript:alert(document.domain)',
            'data:text/html,<script>alert(1)</script>',
            '//evil.com@example.com',
            'https://evil.com%2F@example.com',
            '@evil.com',
            'https://evil.com%09',
            'https://evil.com%0a',
            'https://evil.com%0d',
            'https://evil.com%0d%0a',
            'https://evil.com%00',
            'https://evil.com%23',
            'https://eviláµ‰.com',  # Unicode
        ]
    
    def check_vulnerability(self, response, baseline, payload) -> bool:
        """Check if response indicates open redirect"""
        if not response:
            return False
        
        # Check for redirect status codes
        if response.status_code not in [301, 302, 303, 307, 308]:
            return False
        
        # Get Location header
        location = response.headers.get('Location', '').lower()
        
        if not location:
            return False
        
        # Check if payload appears in Location header
        payload_lower = payload.lower()
        
        # Direct match
        if payload_lower in location:
            return True
        
        # URL-encoded match
        encoded_payload = urllib.parse.quote(payload, safe='').lower()
        if encoded_payload in location:
            return True
        
        # Check for evil domain in location
        if 'evil' in location or 'attacker' in location:
            return True
        
        # Check for external redirect
        if location.startswith('http'):
            # Parse both URLs
            try:
                parsed_location = urllib.parse.urlparse(location)
                parsed_original = urllib.parse.urlparse(response.url)
                
                # If domains differ, it's an external redirect
                if parsed_location.netloc != parsed_original.netloc:
                    return True
            except:
                pass
        
        return False
    
    def get_vulnerability_info(self) -> Dict[str, str]:
        """Return open redirect vulnerability information"""
        return {
            'name': 'Open Redirect',
            'severity': 'medium',
            'description': 'The application is vulnerable to open redirect, allowing attackers to redirect users to arbitrary websites.',
            'cwe': 'CWE-601',
            'owasp': 'A01:2021 - Broken Access Control',
            'impact': 'Phishing attacks, malware distribution, and credential theft through deceptive redirects.',
            'remediation': 'Validate redirect URLs against allowlist, avoid user-controllable redirects, use relative URLs.'
        }
