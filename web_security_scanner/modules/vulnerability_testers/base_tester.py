"""
Base Vulnerability Tester
Abstract base class for all vulnerability testers
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Any
from concurrent.futures import ThreadPoolExecutor, as_completed
import hashlib


class BaseVulnerabilityTester(ABC):
    """Base class for vulnerability testing"""
    
    def __init__(self, scanner_core, config, logger):
        self.scanner = scanner_core
        self.config = config
        self.logger = logger
        self.baseline_responses = {}
        self.vulnerabilities = []
    
    @abstractmethod
    def get_payloads(self) -> List[str]:
        """Return list of payloads for this vulnerability type"""
        pass
    
    @abstractmethod
    def check_vulnerability(self, response, baseline, payload) -> bool:
        """Check if response indicates vulnerability"""
        pass
    
    @abstractmethod
    def get_vulnerability_info(self) -> Dict[str, str]:
        """Return vulnerability metadata (name, severity, etc.)"""
        pass
    
    def test_form(self, form: Dict, max_payloads: int = None) -> List[Dict]:
        """
        Test a form for vulnerabilities
        
        Args:
            form: Form dictionary with 'action', 'method', 'inputs'
            max_payloads: Maximum number of payloads to test
            
        Returns:
            List of discovered vulnerabilities
        """
        vulnerabilities = []
        
        # Get baseline response
        baseline = self._get_baseline_response(form)
        if not baseline:
            self.logger.warning(f"Could not get baseline for {form['action']}")
            return vulnerabilities
        
        # Get payloads
        payloads = self.get_payloads()
        if max_payloads:
            payloads = payloads[:max_payloads]
        
        self.logger.info(f"Testing {len(payloads)} payloads on {form['action']}")
        
        # Test each payload
        def test_payload(payload):
            try:
                # Build request data
                data = {input_name: payload for input_name in form['inputs']}
                
                # Make request
                response = self.scanner.make_request(
                    form['action'],
                    form['method'],
                    data=data
                )
                
                if not response:
                    return None
                
                # Check if vulnerable
                if self.check_vulnerability(response, baseline, payload):
                    vuln_info = self.get_vulnerability_info()
                    return {
                        'url': form['action'],
                        'method': form['method'],
                        'payload': payload,
                        'parameters': list(form['inputs']),
                        'type': vuln_info['name'],
                        'severity': vuln_info['severity'],
                        'description': vuln_info['description'],
                        'cwe': vuln_info.get('cwe'),
                        'owasp': vuln_info.get('owasp')
                    }
                
                return None
                
            except Exception as e:
                self.logger.error(f"Error testing payload: {e}")
                return None
        
        # Execute tests in parallel
        threads = self.config.get('scanner.threads')
        with ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {executor.submit(test_payload, p): p for p in payloads}
            
            for future in as_completed(futures):
                result = future.result()
                if result:
                    vulnerabilities.append(result)
                    self.logger.vulnerability(
                        result['type'],
                        result['url'],
                        {'payload': result['payload']}
                    )
        
        return vulnerabilities
    
    def test_url_parameters(self, url: str, parameters: List[str], max_payloads: int = None) -> List[Dict]:
        """
        Test URL parameters for vulnerabilities
        
        Args:
            url: Base URL
            parameters: List of parameter names
            max_payloads: Maximum payloads to test
            
        Returns:
            List of discovered vulnerabilities
        """
        vulnerabilities = []
        
        payloads = self.get_payloads()
        if max_payloads:
            payloads = payloads[:max_payloads]
        
        for param in parameters:
            # Get baseline
            baseline_data = {param: 'test123'}
            baseline = self.scanner.make_request(url, 'GET', data=baseline_data)
            
            if not baseline:
                continue
            
            # Test payloads
            for payload in payloads:
                try:
                    data = {param: payload}
                    response = self.scanner.make_request(url, 'GET', data=data)
                    
                    if response and self.check_vulnerability(response, baseline, payload):
                        vuln_info = self.get_vulnerability_info()
                        vulnerabilities.append({
                            'url': url,
                            'method': 'GET',
                            'payload': payload,
                            'parameters': [param],
                            'type': vuln_info['name'],
                            'severity': vuln_info['severity'],
                            'description': vuln_info['description'],
                            'cwe': vuln_info.get('cwe'),
                            'owasp': vuln_info.get('owasp')
                        })
                        
                        self.logger.vulnerability(
                            vuln_info['name'],
                            url,
                            {'parameter': param, 'payload': payload}
                        )
                        break  # Move to next parameter after finding vulnerability
                        
                except Exception as e:
                    self.logger.error(f"Error testing parameter {param}: {e}")
        
        return vulnerabilities
    
    def _get_baseline_response(self, form: Dict) -> Dict:
        """Get or create baseline response for a form"""
        form_key = f"{form['action']}-{form['method']}"
        
        if form_key not in self.baseline_responses:
            safe_data = {input_name: "test123" for input_name in form['inputs']}
            response = self.scanner.make_request(form['action'], form['method'], safe_data)
            
            if response:
                self.baseline_responses[form_key] = {
                    'status_code': response.status_code,
                    'length': len(response.text),
                    'text': response.text,
                    'hash': hashlib.md5(response.text.encode()).hexdigest()
                }
        
        return self.baseline_responses.get(form_key)
    
    def _response_differs_significantly(self, response, baseline) -> bool:
        """Check if response differs significantly from baseline"""
        if not response or not baseline:
            return False
        
        # Status code difference
        if response.status_code != baseline['status_code']:
            return True
        
        # Length difference (more than 10%)
        length_diff = abs(len(response.text) - baseline['length'])
        if length_diff > baseline['length'] * 0.1:
            return True
        
        # Hash difference
        response_hash = hashlib.md5(response.text.encode()).hexdigest()
        if response_hash != baseline['hash']:
            # Check if difference is more than whitespace
            if length_diff > 50:
                return True
        
        return False
